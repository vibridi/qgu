package com.vibridi.qgu.widget;

import java.util.Arrays;
import java.util.TreeSet;

import com.vibridi.fxu.dialog.FXDialog;
import com.vibridi.fxu.input.DatePickerTableCell;
import com.vibridi.fxu.keyboard.FXKeyboard;
import com.vibridi.qgu.model.GanttTask;
import com.vibridi.qgu.util.TaskUtils;
import com.vibridi.qgu.widget.api.TaskListener;
import com.vibridi.qgu.widget.api.TaskVisitor;

import javafx.beans.binding.Bindings;
import javafx.collections.ListChangeListener;
import javafx.scene.control.ButtonType;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.CellEditEvent;
import javafx.scene.control.TableRow;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.TextFieldTableCell;

public class TaskTableView extends TableView<ObservableGanttTask> {
	
	private static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";	 // TODO put in options
	private final static String NEW_CHILD_KEY_SHORTCUT = "Ctrl+Shift+N";
	private final static String NEW_SIBLING_KEY_SHORTCUT = "Ctrl+Alt+N";
	private final static String DELETE_KEY_SHORTCUT = "Ctrl+Backspace";
	
	private final GanttTask listRoot;
	private final TableColumn<ObservableGanttTask, String> title;
	private final TableColumn<ObservableGanttTask, String> taskId;
	private final TableColumn<ObservableGanttTask, String> taskName;
	private final TableColumn<ObservableGanttTask, String> startDate;
	private final TableColumn<ObservableGanttTask, String> endDate;
	
	private TaskListener taskListener;
	private TreeSet<ObservableGanttTask> absoluteList;
	
	public TaskTableView() {
		this(DEFAULT_DATE_FORMAT);
	}
	
	public TaskTableView(String datePattern) {		
		listRoot = new GanttTask("root");
		
		setEditable(true);
		setRowFactory(this::tableRowFactory);
		getItems().addListener(this::onChange);
		getStyleClass().add("qgu-task-list");
		
		title = new TableColumn<ObservableGanttTask,String>("Task List");
		
		taskId = new TableColumn<ObservableGanttTask,String>("Id");
		taskId.setCellValueFactory(cellData -> cellData.getValue().idProperty());
		taskId.setSortable(false);
		
		taskName = new TableColumn<ObservableGanttTask,String>("Task");
		taskName.setCellValueFactory(cellData -> cellData.getValue().nameProperty());
		taskName.setCellFactory(TextFieldTableCell.<ObservableGanttTask>forTableColumn());
		taskName.setOnEditCommit(this::onTaskNameEditCommit);
		taskName.setSortable(false);
		
		startDate = new TableColumn<ObservableGanttTask,String>("Start");
		startDate.setCellValueFactory(cellData -> cellData.getValue().startDateProperty());
		startDate.setCellFactory(DatePickerTableCell.<ObservableGanttTask>forTableColumn(datePattern));
		startDate.setOnEditCommit(this::onStartDateEditCommit);
		startDate.setSortable(false);
		
		endDate = new TableColumn<ObservableGanttTask,String>("End");
		endDate.setCellValueFactory(cellData -> cellData.getValue().endDateProperty());
		endDate.setCellFactory(DatePickerTableCell.<ObservableGanttTask>forTableColumn(datePattern));
		endDate.setOnEditCommit(this::onEndDateEditCommit);
		endDate.setSortable(false);
		
		title.getColumns().add(taskId);
		title.getColumns().add(taskName);
		title.getColumns().add(startDate);
		title.getColumns().add(endDate);
		
		taskId.prefWidthProperty().bind(this.widthProperty().multiply(0.12));
		taskName.prefWidthProperty().bind(this.widthProperty().multiply(0.37));
		startDate.prefWidthProperty().bind(this.widthProperty().multiply(0.255));
		endDate.prefWidthProperty().bind(this.widthProperty().multiply(0.255));		
		title.prefWidthProperty().bind(this.widthProperty());
		
		getColumns().add(title);

		absoluteList = new TreeSet<>();
		
		FXKeyboard.setKeyCombinationShortcut(this, NEW_CHILD_KEY_SHORTCUT, event -> shortcutAddChild());
		FXKeyboard.setKeyCombinationShortcut(this, NEW_SIBLING_KEY_SHORTCUT, event -> shortcutAddSibling());
		FXKeyboard.setKeyCombinationShortcut(this, DELETE_KEY_SHORTCUT, event -> shortcutDelete());
	}
	
	// used to propagate events generated by keyboard shortcuts
	public void addTaskListener(TaskListener lsnr) {
		taskListener = lsnr;
	}
	
	/**
	 * Adds a task to the root node
	 * 
	 * @param task
	 * @return The absolute index of the new task in the task list
	 */
	public int addTask(GanttTask task) {
		listRoot.addChild(task);
		ObservableGanttTask obs = new ObservableGanttTask(task);
		getItems().add(obs);
		return makeInternalRepresentation(obs);
	}
	
	/**
	 * Adds an existing task as child of a specific item in the task tree
	 * 
	 * @param task The gantt task
	 * @param path The path identifying the node parent of this task
	 * @return The absolute index of the new task in the task list
	 */
	public int addTask(GanttTask task, int... path) {
		listRoot.addChild(task, path);	
		ObservableGanttTask obs = new ObservableGanttTask(task);
		int i = makeInternalRepresentation(obs);
		getItems().add(i, obs);
		return i;
	}
	
	/**
	 * Removes the task at the specified position from the list. It also removes this task's children.
	 *  
	 * @param at Index of the task that will be removed
	 * @return Number of items removed from the list
	 */
	public int removeTask(int at) {
		
		// remove item at the specified position
		ObservableGanttTask obs = getItems().remove(at);
		removeInternalRepresentation(obs);
		listRoot.removeChild(obs.getTask().getPath());
		
		int lv = obs.getTaskLevel();
		int howManyRemoved = 1;
		
		// remove children
		for(; at < getItems().size() && getItems().get(at).getTaskLevel() > lv; howManyRemoved++)
			removeInternalRepresentation(getItems().remove(at));
		
		// update siblings and nephews
		for(int i = at; i < getItems().size() && getItems().get(i).getTaskLevel() >= lv; i++)
			getItems().get(i).updateId();
		
		return howManyRemoved;
	}
	
	public GanttTask getGanttRoot() {
		return listRoot;
	}
	
	public void walkDepthFirst(TaskVisitor callback) {
		TaskUtils.walkDepthFirst(listRoot, callback);
	}
	
	public void clear() {
		getItems().clear();
		listRoot.clear();
	}
	
	
	/*********************************************
	 *                                           *
	 * PRIVATE METHODS		                     *
	 *                                           *
	 *********************************************/
	public void onChange(ListChangeListener.Change<? extends ObservableGanttTask> change) {
		while (change.next()) {
			if(change.wasAdded()) {				
				for (int i = 0; i < change.getAddedSize(); i++) {
					taskListener.taskAddedEvent(change.getFrom()+i, change.getAddedSubList().get(i).getTask());
				}
							
			} else if(change.wasRemoved()) {
				for (int i = 0; i < change.getRemovedSize(); i++) {
					taskListener.taskRemovedEvent(change.getFrom()+i);
				}
				
			} else if(change.wasPermutated()) {
				for (int i = change.getFrom(); i < change.getTo(); i++) {
					//permutate
				}
			}
		} // end while
	}
	
	private void onTaskNameEditCommit(CellEditEvent<ObservableGanttTask, String> event) {
		if(event.getOldValue().equals(event.getNewValue())) {
			event.consume();
			return;
		}
		event.getRowValue().setName(event.getNewValue());
		//onEditCommit(event); // TODO maybe not necessary to propagate name change
	}
	
	private void onStartDateEditCommit(CellEditEvent<ObservableGanttTask, String> event) {
		if(event.getOldValue().equals(event.getNewValue())) {
			event.consume();
			return;
		}
		event.getRowValue().setStartDate(event.getNewValue());
		onEditCommit(event);
	}
	
	private void onEndDateEditCommit(CellEditEvent<ObservableGanttTask, String> event) {
		if(event.getOldValue().equals(event.getNewValue())) {
			event.consume();
			return;
		}
		event.getRowValue().setEndDate(event.getNewValue());
		onEditCommit(event);
	}
	
	private void onEditCommit(CellEditEvent<ObservableGanttTask, String> event) {
		taskListener.taskEditedEvent(event.getTablePosition().getRow(), event.getRowValue().getTask());
	}
	
	/*********************************************
	 *                                           *
	 * CONTEXT MENU FACTORY	                     *
	 *                                           *
	 *********************************************/
	private TableRow<ObservableGanttTask> tableRowFactory(TableView<ObservableGanttTask> table) {
		final TableRow<ObservableGanttTask> row = new TableRow<>();
	    
		row.contextMenuProperty().bind(
				Bindings.when(Bindings.isNull(row.itemProperty()))
					.then((ContextMenu)null)
					.otherwise(Bindings.when(row.indexProperty().isEqualTo(0))
							.then(makeFirstTaskContextMenu())
							.otherwise(makeRegularTaskContextMenu(row))));
	    return row;
	}
	
	private ContextMenu makeFirstTaskContextMenu() {
		ContextMenu rowMenu = new ContextMenu();
		rowMenu.getItems().addAll(childMenuItem(), siblingMenuItem());
		return rowMenu;
	}
	
	private ContextMenu makeRegularTaskContextMenu(TableRow<ObservableGanttTask> row) {
		ContextMenu rowMenu = new ContextMenu();
		rowMenu.getItems().addAll(childMenuItem(), siblingMenuItem(), deleteMenuItem(row));
		return rowMenu;
	}
	
	private MenuItem childMenuItem() {
		MenuItem newChildItem = new MenuItem("New child task");
	    newChildItem.setAccelerator(FXKeyboard.buildKeyCombination(NEW_CHILD_KEY_SHORTCUT));
	    newChildItem.setOnAction(event -> shortcutAddChild());
	    return newChildItem;
	}
	
	private MenuItem siblingMenuItem() {
	    MenuItem newSiblingItem = new MenuItem("New sibling task");
	    newSiblingItem.setAccelerator(FXKeyboard.buildKeyCombination(NEW_SIBLING_KEY_SHORTCUT));
	    newSiblingItem.setOnAction(event -> shortcutAddSibling());
	    return newSiblingItem;
	}
	
	private MenuItem deleteMenuItem(TableRow<ObservableGanttTask> row) {
	    MenuItem removeItem = new MenuItem("Delete task");
	    removeItem.setAccelerator(FXKeyboard.buildKeyCombination(DELETE_KEY_SHORTCUT));
	    removeItem.setOnAction(event -> shortcutDelete(row.getIndex(), row.getItem()));
	    return removeItem;
	}
	
	
	/*********************************************
	 *                                           *
	 * ACTIONS				                     *
	 *                                           *
	 *********************************************/
	private void shortcutAddChild() {
		ObservableGanttTask obs = getSelectionModel().getSelectedItem();
		if(obs == null)
			return;
		if(obs.getTask().getLevel() >= 3)
			return;
	
		addTask(new GanttTask("New Task"), obs.getTask().getPath());
	}
	
	private void shortcutAddSibling() {
		ObservableGanttTask obs = getSelectionModel().getSelectedItem();
		if(obs == null)
			return;
		if(obs.getTask().getLevel() > 3)
			return;
		
		if(obs.getTask().getLevel() == 1)
			addTask(new GanttTask("New Task"));
		else
			addTask(new GanttTask("New Task"), Arrays.copyOf(obs.getTask().getPath(), obs.getTask().getLevel() - 1));
	}
	
	private void shortcutDelete() {
		shortcutDelete(-1, null);
	}
	
	private void shortcutDelete(int index, ObservableGanttTask obs) {
		if(index == -1 || obs == null) {
			index = getSelectionModel().getSelectedIndex();
			obs = getSelectionModel().getSelectedItem();
		}

		if(obs == null || index == 0)
			return;
		
		if(obs.getTask().size() > 0) {
			ButtonType type = FXDialog.binaryChoiceAlert("This will delete also all sub-tasks. Proceed?").showAndWait().get();
			if(type == ButtonType.NO)
				return;
		}
		
		removeTask(index);
	}
	
	private int makeInternalRepresentation(ObservableGanttTask obs) {
		absoluteList.add(obs);
		return absoluteIndex(obs);
	}
	
	private void removeInternalRepresentation(ObservableGanttTask obs) {
		absoluteList.remove(obs);
	}
	
	private int absoluteIndex(ObservableGanttTask obs) {
		if(!absoluteList.contains(obs))
			return -1;
		return absoluteList.headSet(obs).size();
	}
	
//	private Boolean onDebug(Integer absoluteIndex, ObservableGanttTask task) {
//		System.out.print(task.getTask().getName() + " path:\t");
//		TaskUtils.printPath(task.getTask().getPath());
//		return true;
//	}

}
