package com.vibridi.qgu.widget;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

import com.vibridi.fxu.dialog.FXDialog;
import com.vibridi.fxu.keyboard.FXKeyboard;
import com.vibridi.qgu.model.GanttTask;
import com.vibridi.qgu.util.TaskUtils;
import com.vibridi.qgu.widget.api.TaskListener;
import com.vibridi.qgu.widget.api.TaskTreeWalkerCallback;

import javafx.beans.property.SimpleStringProperty;
import javafx.scene.control.ButtonType;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.TextFieldTableCell;

public class TaskTableView extends TableView<ObservableGanttTask> {
	
	private final GanttTask listRoot;
	private final TableColumn<ObservableGanttTask, String> title;
	private final TableColumn<ObservableGanttTask, String> taskId;
	private final TableColumn<ObservableGanttTask, String> taskName;
	private final TableColumn<ObservableGanttTask, String> startDate;
	private final TableColumn<ObservableGanttTask, String> endDate;
	
	private TaskListener taskListener;
	private TreeSet<ObservableGanttTask> absoluteList;
	
	public TaskTableView() {		
		listRoot = new GanttTask("root");
		
		setEditable(true);
		
		title = new TableColumn<ObservableGanttTask,String>("Task List");
		
		taskId = new TableColumn<ObservableGanttTask,String>("Id");
		taskId.setCellValueFactory(cellData -> cellData.getValue().idProperty());
		taskId.setCellFactory(TextFieldTableCell.<ObservableGanttTask>forTableColumn());
		taskId.setSortable(false);
		
		taskName = new TableColumn<ObservableGanttTask,String>("Task");
		taskName.setCellValueFactory(cellData -> cellData.getValue().nameProperty());
		taskName.setCellFactory(TextFieldTableCell.<ObservableGanttTask>forTableColumn());
		taskName.setSortable(false);
		
		startDate = new TableColumn<ObservableGanttTask,String>("Start");
		startDate.setCellValueFactory(cellData -> cellData.getValue().startDateProperty());
		startDate.setCellFactory(TextFieldTableCell.<ObservableGanttTask>forTableColumn());
		startDate.setSortable(false);
		
		endDate = new TableColumn<ObservableGanttTask,String>("End");
		endDate.setCellValueFactory(cellData -> cellData.getValue().endDateProperty());
		endDate.setCellFactory(TextFieldTableCell.<ObservableGanttTask>forTableColumn());
		endDate.setSortable(false);
		
		title.getColumns().add(taskId);
		title.getColumns().add(taskName);
		title.getColumns().add(startDate);
		title.getColumns().add(endDate);
		
		taskId.prefWidthProperty().bind(this.widthProperty().multiply(0.15));
		taskName.prefWidthProperty().bind(this.widthProperty().multiply(0.40));
		startDate.prefWidthProperty().bind(this.widthProperty().multiply(0.225));
		endDate.prefWidthProperty().bind(this.widthProperty().multiply(0.225));		
		title.prefWidthProperty().bind(this.widthProperty());
		
		getColumns().add(title);

		absoluteList = new TreeSet<>();
		
		FXKeyboard.setKeyCombinationShortcut(this, "Ctrl+Shift+N", event -> shortcutAddChild());
		FXKeyboard.setKeyCombinationShortcut(this, "Ctrl+Alt+N", event -> shortcutAddSibling());
		FXKeyboard.setKeyCombinationShortcut(this, "Ctrl+Backspace", event -> shortcutDelete());
//		FXKeyboard.setKeyCombinationShortcut(this, "Ctrl+Shift+I", event -> );
	}
	
	// used to propagate events generated by keyboard shortcuts
	public void addTaskListener(TaskListener lsnr) {
		taskListener = lsnr;
	}
	
	/**
	 * Adds a task to the root node
	 * 
	 * @param task
	 * @return The absolute index of the new task in the task list
	 */
	public int addTask(GanttTask task) {
		listRoot.addChild(task);
		ObservableGanttTask obs = new ObservableGanttTask(task);
		getItems().add(obs);
		return makeInternalRepresentation(obs);
	}
	
	/**
	 * Adds an existing task as child of a specific item in the task tree
	 * 
	 * @param task The gantt task
	 * @param path The path identifying the node parent of this task
	 * @return The absolute index of the new task in the task list
	 */
	public int addTask(GanttTask task, int... path) {
		listRoot.addChild(task, path);	
		ObservableGanttTask obs = new ObservableGanttTask(task);
		int i = makeInternalRepresentation(obs);
		getItems().add(i, obs);
		return i;
	}
	
	public void removeTask(int at) { // TODO consider returning task
		ObservableGanttTask obs = getItems().remove(at);
		removeInternalRepresentation(obs);
		listRoot.removeChild(obs.getTask().getPath());
	}
	
	public GanttTask getGanttRoot() {
		return listRoot;
	}
	
	public void walkDepthFirst(TaskTreeWalkerCallback callback) {
		TaskUtils.walkDepthFirst(listRoot, callback);
	}
	
	public void clearTaskTree() {
		listRoot.clear();
	}
	
	/* ******************
	 * PRIVATE METHODS
	 * ******************/
	private void shortcutAddChild() {
		ObservableGanttTask obs = getSelectionModel().getSelectedItem();
		if(obs == null)
			return;
		if(obs.getTask().getLevel() >= 3)
			return;
	
		GanttTask task = new GanttTask("New Task");
		int index = addTask(task, obs.getTask().getPath());
		taskListener.taskAddedEvent(index, task);
	}
	
	private void shortcutAddSibling() {
		ObservableGanttTask obs = getSelectionModel().getSelectedItem();
		if(obs == null)
			return;
		if(obs.getTask().getLevel() > 3)
			return;
		
		GanttTask task = new GanttTask("New Task");
		int index = (obs.getTask().getLevel() == 1) ?
			addTask(task) :
			addTask(task, Arrays.copyOf(obs.getTask().getPath(), obs.getTask().getLevel() - 1));
		taskListener.taskAddedEvent(index, task);
	}
	
	private void shortcutDelete() {
		int index = getSelectionModel().getSelectedIndex();
		ObservableGanttTask obs = getSelectionModel().getSelectedItem();
		if(obs == null)
			return;
		
		if(obs.getTask().size() > 0) {
			ButtonType type = FXDialog.binaryChoiceAlert("This will delete also all sub-tasks. Proceed?").showAndWait().get();
			if(type == ButtonType.NO)
				return;
		}
		
		removeTask(index);
		taskListener.taskRemovedEvent(index, obs.getTask());
	}
	
	private int makeInternalRepresentation(ObservableGanttTask obs) {
		absoluteList.add(obs);
		return absoluteIndex(obs);
	}
	
	private void removeInternalRepresentation(ObservableGanttTask obs) {
		absoluteList.remove(obs);
	}
	
	private int absoluteIndex(ObservableGanttTask obs) {
		if(!absoluteList.contains(obs))
			return -1;
		return absoluteList.headSet(obs).size();
	}

	
	private Boolean onDebug(Integer absoluteIndex, ObservableGanttTask task) {
		System.out.print(task.getTask().getName() + " path:\t");
		TaskUtils.printPath(task.getTask().getPath());
		return true;
	}

}
